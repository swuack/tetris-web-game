<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tetris Web Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* 폰트 설정: 레트로 스타일은 'Press Start 2P', 일반 텍스트는 'Inter' */
        :root {
            --board-width: 10;
            --board-height: 20;
            --block-size: min(3.5vh, 3.5vw, 30px); /* 반응형 블록 크기 */
            --game-width: calc(var(--board-width) * var(--block-size));
            --game-height: calc(var(--board-height) * var(--block-size));
            --bg-dark: #1f2937;
            --text-neon-pink: #ff69b4;
            --text-neon-yellow: #fff200;
        }

        body {
            background-color: var(--bg-dark);
            color: white;
            font-family: 'Inter', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }

        #game-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
            align-items: center;
        }

        @media (min-width: 768px) {
            #game-container {
                flex-direction: row;
                align-items: flex-start;
            }
        }

        #game-board {
            width: var(--game-width);
            height: var(--game-height);
            background-color: #000000;
            border: 4px solid var(--text-neon-pink);
            display: grid;
            grid-template-columns: repeat(var(--board-width), 1fr);
            grid-template-rows: repeat(var(--board-height), 1fr);
            box-shadow: 0 0 20px rgba(255, 105, 180, 0.5);
        }

        .block {
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-sizing: border-box;
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.5);
            transition: background-color 0.1s;
        }

        #score-board h2, #score-board div {
            font-family: 'Press Start 2P', cursive;
        }
        
        #score-board {
            min-width: 150px;
            padding: 1rem;
            border: 2px solid var(--text-neon-yellow);
            background-color: #111827;
            box-shadow: 0 0 15px rgba(255, 242, 0, 0.5);
            border-radius: 8px;
        }

        #next-piece-display {
            width: calc(4 * var(--block-size));
            height: calc(4 * var(--block-size));
            margin-top: 10px;
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(4, 1fr);
            background-color: #0a0e14;
            border-radius: 4px;
            border: 1px solid #374151;
        }

        .piece-next-block {
             box-sizing: border-box;
        }

        .control-button {
            background-color: #3b82f6; /* Blue */
            color: white;
            padding: 10px 20px;
            border-radius: 9999px; /* Fully rounded */
            font-weight: bold;
            transition: background-color 0.15s, transform 0.1s;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .control-button:hover {
            background-color: #2563eb; /* Darker blue */
        }

        .control-button:active {
            transform: translateY(1px);
        }

        #mobile-controls {
            display: grid;
            grid-template-areas:
                ". up ."
                "left down right"
                ". rotate .";
            gap: 10px;
            margin-top: 20px;
        }

        .mobile-control {
            grid-area: var(--area);
            font-size: 1.25rem;
            padding: 10px;
            min-width: 60px;
            min-height: 60px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        @media (min-width: 768px) {
            #mobile-controls {
                display: none; /* 데스크톱에서는 숨김 */
            }
        }
    </style>
</head>
<body>

<div id="game-container" class="p-4 md:p-8">
    
    <!-- 1. 게임 보드 (캔버스 역할) -->
    <div id="game-board" class="w-full">
        <!-- 보드 셀들은 JavaScript로 채워집니다 -->
    </div>

    <!-- 2. 스코어 보드 및 NEXT 블록 -->
    <div id="score-board" class="flex flex-col gap-6 w-full md:w-auto">
        <h2 class="text-2xl text-center text-red-400">TETRIS</h2>
        
        <div class="flex justify-between items-center border-b border-gray-700 pb-2">
            <span class="text-lg text-gray-400">SCORE:</span>
            <span id="score" class="text-3xl text-yellow-300">0</span>
        </div>

        <div class="flex justify-between items-center border-b border-gray-700 pb-2">
            <span class="text-lg text-gray-400">LEVEL:</span>
            <span id="level" class="text-3xl text-green-400">1</span>
        </div>

        <div>
            <span class="text-lg text-gray-400 block mb-2">NEXT:</span>
            <div id="next-piece-display" class="mx-auto">
                <!-- 다음 블록이 JavaScript로 여기에 그려집니다 -->
            </div>
        </div>

        <button id="start-button" class="control-button bg-green-500 hover:bg-green-600 mt-4">
            START GAME (Press Enter)
        </button>
        
        <div id="game-status" class="text-center mt-4 text-xl text-red-500 hidden">GAME OVER</div>

        <div id="message-box" class="text-center mt-4 text-lg text-white">Press START to begin!</div>
    </div>

    <!-- 3. 모바일 컨트롤 (터치) -->
    <div id="mobile-controls" class="w-full max-w-sm mx-auto">
        <button class="mobile-control control-button" style="--area: up;" id="control-up">
            &#9650;
        </button>
        <button class="mobile-control control-button" style="--area: left;" id="control-left">
            &#9664;
        </button>
        <button class="mobile-control control-button" style="--area: down;" id="control-down">
            &#9660;
        </button>
        <button class="mobile-control control-button" style="--area: right;" id="control-right">
            &#9654;
        </button>
        <button class="mobile-control control-button bg-purple-500 hover:bg-purple-600" style="--area: rotate;" id="control-rotate">
            &#x21BA;
        </button>
    </div>
</div>

<script>
    // =================================================================
    // JavaScript Game Logic
    // =================================================================

    const BOARD_WIDTH = 10;
    const BOARD_HEIGHT = 20;
    const START_LEVEL = 1;
    const POINTS = { 1: 100, 2: 300, 3: 500, 4: 800 };

    const boardElement = document.getElementById('game-board');
    const scoreElement = document.getElementById('score');
    const levelElement = document.getElementById('level');
    const statusElement = document.getElementById('game-status');
    const nextPieceDisplay = document.getElementById('next-piece-display');
    const startButton = document.getElementById('start-button');
    const messageBox = document.getElementById('message-box');

    // 모바일 컨트롤 이벤트 리스너
    document.getElementById('control-left').addEventListener('click', () => handleUserInput('left'));
    document.getElementById('control-right').addEventListener('click', () => handleUserInput('right'));
    document.getElementById('control-down').addEventListener('click', () => handleUserInput('down'));
    document.getElementById('control-rotate').addEventListener('click', () => handleUserInput('rotate'));
    document.getElementById('control-up').addEventListener('click', () => handleUserInput('rotate')); // 'Up' for rotate

    // 블록 모양과 색상 정의 (Tetrominoes)
    const SHAPES = [
        // I (Cyan)
        [[0, 0, 0, 0], [1, 1, 1, 1], [0, 0, 0, 0], [0, 0, 0, 0]],
        // J (Blue)
        [[1, 0, 0], [1, 1, 1], [0, 0, 0]],
        // L (Orange)
        [[0, 0, 1], [1, 1, 1], [0, 0, 0]],
        // O (Yellow)
        [[1, 1], [1, 1]],
        // S (Green)
        [[0, 1, 1], [1, 1, 0], [0, 0, 0]],
        // T (Purple)
        [[0, 1, 0], [1, 1, 1], [0, 0, 0]],
        // Z (Red)
        [[1, 1, 0], [0, 1, 1], [0, 0, 0]]
    ];

    const COLORS = [
        'bg-cyan-400', // I
        'bg-blue-600', // J
        'bg-orange-500', // L
        'bg-yellow-400', // O
        'bg-green-500', // S
        'bg-purple-500', // T
        'bg-red-500' // Z
    ];

    let board;
    let currentPiece;
    let nextPiece;
    let score;
    let level;
    let linesCleared;
    let gameLoop;
    let isPlaying = false;
    let dropInterval = 1000; // 초기 드롭 간격 (ms)

    // =================================================================
    // 게임 초기화
    // =================================================================
    function initBoard() {
        board = Array.from({ length: BOARD_HEIGHT }, () => 
            Array(BOARD_WIDTH).fill(null) // null은 빈 셀, 문자열은 고정된 블록의 색상 클래스
        );
        // HTML 보드 셀 생성
        boardElement.innerHTML = '';
        boardElement.style.setProperty('--board-width', BOARD_WIDTH);
        boardElement.style.setProperty('--board-height', BOARD_HEIGHT);

        for (let i = 0; i < BOARD_WIDTH * BOARD_HEIGHT; i++) {
            const cell = document.createElement('div');
            cell.classList.add('block');
            boardElement.appendChild(cell);
        }
    }

    function resetGame() {
        initBoard();
        score = 0;
        level = START_LEVEL;
        linesCleared = 0;
        dropInterval = 1000;
        isPlaying = true;
        
        scoreElement.textContent = score;
        levelElement.textContent = level;
        statusElement.classList.add('hidden');
        messageBox.textContent = 'Use Arrow Keys or Buttons to play!';
        startButton.textContent = 'PAUSE (P)';
        startButton.classList.remove('bg-green-500');
        startButton.classList.add('bg-red-500');

        nextPiece = generateNewPiece();
        currentPiece = getNextPiece();
        
        // 키보드 및 버튼 이벤트 활성화
        document.addEventListener('keydown', handleKeyDown); // <-- 키 다운 이벤트 리스너
        startButton.removeEventListener('click', startGame);
        startButton.addEventListener('click', pauseGame);

        startGameLoop();
        updateDisplay();
    }

    function generateNewPiece() {
        const shapeIndex = Math.floor(Math.random() * SHAPES.length);
        const shape = SHAPES[shapeIndex];
        const color = COLORS[shapeIndex];
        
        return {
            shape: shape,
            color: color,
            x: Math.floor((BOARD_WIDTH - shape[0].length) / 2),
            y: 0
        };
    }
    
    function getNextPiece() {
        const piece = nextPiece;
        nextPiece = generateNewPiece();
        drawNextPiece();
        return piece;
    }

    // =================================================================
    // 게임 루프 및 블록 이동
    // =================================================================

    function startGameLoop() {
        if (!isPlaying) return;

        // 이전 루프 정리
        if (gameLoop) clearInterval(gameLoop);

        // 새로운 루프 시작
        gameLoop = setInterval(() => {
            if (isPlaying) {
                movePiece(0, 1);
            }
        }, dropInterval);
    }

    function pauseGame() {
        if (!isPlaying) return; // 이미 일시정지 상태라면 무시

        isPlaying = false;
        clearInterval(gameLoop);
        messageBox.textContent = 'Game Paused (Press P or click button)';
        startButton.textContent = 'RESUME (R)';
        startButton.classList.remove('bg-red-500');
        startButton.classList.add('bg-blue-500');

        startButton.removeEventListener('click', pauseGame);
        startButton.addEventListener('click', resumeGame);
    }

    function resumeGame() {
        if (isPlaying) return; // 이미 플레이 중이라면 무시
        
        isPlaying = true;
        messageBox.textContent = 'Use Arrow Keys or Buttons to play!';
        startButton.textContent = 'PAUSE (P)';
        startButton.classList.remove('bg-blue-500');
        startButton.classList.add('bg-red-500');
        
        startButton.removeEventListener('click', resumeGame);
        startButton.addEventListener('click', pauseGame);

        startGameLoop();
    }

    function movePiece(dx, dy) {
        if (!currentPiece) return;

        const newX = currentPiece.x + dx;
        const newY = currentPiece.y + dy;

        if (isValidMove(currentPiece.shape, newX, newY)) {
            currentPiece.x = newX;
            currentPiece.y = newY;
            updateDisplay();
        } else if (dy === 1) {
            // 아래로 이동이 불가능하면 블록을 고정
            lockPiece();
            // 라인 제거 확인 및 새 블록 생성
            clearLines();
            currentPiece = getNextPiece();
            
            // 새 블록이 고정되자마자 충돌하면 게임 오버
            if (!isValidMove(currentPiece.shape, currentPiece.x, currentPiece.y)) {
                gameOver();
            } else {
                updateDisplay();
                startGameLoop(); // 속도 변경을 위해 루프 재시작
            }
        }
    }

    function rotatePiece() {
        if (!currentPiece) return;

        const originalShape = currentPiece.shape;
        const newShape = rotateMatrix(originalShape);

        // 회전 후 유효성 검사
        if (isValidMove(newShape, currentPiece.x, currentPiece.y)) {
            currentPiece.shape = newShape;
            updateDisplay();
        }
        // (벽차기(Wall Kick) 로직은 복잡하여 일단 생략합니다)
    }

    function rotateMatrix(matrix) {
        const N = matrix.length;
        const rotated = Array.from({ length: N }, () => Array(N).fill(0));
        for (let i = 0; i < N; i++) {
            for (let j = 0; j < N; j++) {
                rotated[j][N - 1 - i] = matrix[i][j];
            }
        }
        return rotated;
    }

    function dropPiece() {
        if (!currentPiece) return;
        while (isValidMove(currentPiece.shape, currentPiece.x, currentPiece.y + 1)) {
            currentPiece.y++;
        }
        movePiece(0, 1); // 고정 로직 실행
    }

    // =================================================================
    // 충돌 및 고정
    // =================================================================

    function isValidMove(shape, x, y) {
        for (let row = 0; row < shape.length; row++) {
            for (let col = 0; col < shape[row].length; col++) {
                if (shape[row][col]) { // 블록이 있는 셀인 경우
                    const boardX = x + col;
                    const boardY = y + row;

                    // 1. 보드 경계 확인
                    if (boardX < 0 || boardX >= BOARD_WIDTH || boardY >= BOARD_HEIGHT) {
                        return false;
                    }
                    // 2. 이미 채워진 블록과의 충돌 확인 (Y좌표가 0보다 클 때만)
                    if (boardY >= 0 && board[boardY][boardX]) {
                        return false;
                    }
                }
            }
        }
        return true;
    }

    function lockPiece() {
        for (let row = 0; row < currentPiece.shape.length; row++) {
            for (let col = 0; col < currentPiece.shape[row].length; col++) {
                if (currentPiece.shape[row][col]) {
                    const boardX = currentPiece.x + col;
                    const boardY = currentPiece.y + row;
                    if (boardY >= 0) { // 보드 밖으로 나가지 않은 경우만 고정
                        board[boardY][boardX] = currentPiece.color;
                    }
                }
            }
        }
    }

    // =================================================================
    // 라인 클리어 및 점수 계산
    // =================================================================

    function clearLines() {
        let linesRemoved = 0;
        
        for (let y = BOARD_HEIGHT - 1; y >= 0; y--) {
            // 현재 라인이 모두 채워졌는지 확인
            const isLineFull = board[y].every(cell => cell !== null);

            if (isLineFull) {
                linesRemoved++;
                // 라인 삭제 (위의 라인을 한 칸씩 아래로 내림)
                for (let k = y; k > 0; k--) {
                    board[k] = [...board[k - 1]]; // 윗 줄 복사
                }
                board[0] = Array(BOARD_WIDTH).fill(null); // 최상단 라인 초기화
                y++; // 라인이 내려왔으므로, 새로 내려온 라인을 다시 검사하기 위해 y를 증가
            }
        }

        if (linesRemoved > 0) {
            linesCleared += linesRemoved;
            // 점수 계산 (콤보 점수)
            score += POINTS[linesRemoved] || 0;
            updateLevel();
        }
    }

    function updateLevel() {
        const newLevel = Math.floor(linesCleared / 10) + START_LEVEL;
        if (newLevel !== level) {
            level = newLevel;
            dropInterval = Math.max(100, 1000 - (level - 1) * 75); // 레벨당 속도 증가 (최소 100ms)
            startGameLoop(); // 속도 변경 적용을 위해 루프 재시작
        }
        levelElement.textContent = level;
    }

    // =================================================================
    // 화면 그리기 (렌더링)
    // =================================================================

    function getBoardCellIndex(row, col) {
        return row * BOARD_WIDTH + col;
    }

    function updateDisplay() {
        // 1. 보드의 고정된 블록 그리기
        for (let row = 0; row < BOARD_HEIGHT; row++) {
            for (let col = 0; col < BOARD_WIDTH; col++) {
                const cellIndex = getBoardCellIndex(row, col);
                const cellElement = boardElement.children[cellIndex];
                
                // 기존 클래스 제거 (tailwind bg-*)
                cellElement.className = 'block'; 
                
                if (board[row][col]) {
                    cellElement.classList.add(board[row][col]);
                }
            }
        }

        // 2. 현재 움직이는 블록 그리기
        if (currentPiece) {
            for (let row = 0; row < currentPiece.shape.length; row++) {
                for (let col = 0; col < currentPiece.shape[row].length; col++) {
                    if (currentPiece.shape[row][col]) {
                        const boardY = currentPiece.y + row;
                        const boardX = currentPiece.x + col;
                        
                        if (boardY >= 0 && boardY < BOARD_HEIGHT && boardX >= 0 && boardX < BOARD_WIDTH) {
                            const cellIndex = getBoardCellIndex(boardY, boardX);
                            boardElement.children[cellIndex].classList.add(currentPiece.color);
                        }
                    }
                }
            }
        }
        
        // 3. 점수 업데이트
        scoreElement.textContent = score;
    }

    function drawNextPiece() {
        // Next Piece 보드 초기화
        nextPieceDisplay.innerHTML = '';
        for (let i = 0; i < 16; i++) {
            const cell = document.createElement('div');
            cell.classList.add('piece-next-block');
            nextPieceDisplay.appendChild(cell);
        }

        // Next Piece 그리기 (4x4 기준)
        const shape = nextPiece.shape;
        const color = nextPiece.color;
        
        const centerOffset = (4 - shape[0].length) / 2; // 중앙 정렬

        for (let row = 0; row < shape.length; row++) {
            for (let col = 0; col < shape[row].length; col++) {
                if (shape[row][col]) {
                    // 4x4 디스플레이 내 좌표 계산
                    const displayY = row + Math.floor(centerOffset);
                    const displayX = col + Math.floor(centerOffset);
                    
                    const cellIndex = displayY * 4 + displayX;
                    if (cellIndex >= 0 && cellIndex < 16) {
                         nextPieceDisplay.children[cellIndex].classList.add(color);
                    }
                }
            }
        }
    }

    // =================================================================
    // 이벤트 핸들러
    // =================================================================

    function handleUserInput(action) {
        if (!isPlaying) return;

        switch (action) {
            case 'left':
                movePiece(-1, 0);
                break;
            case 'right':
                movePiece(1, 0);
                break;
            case 'down':
                movePiece(0, 1);
                break;
            case 'rotate':
                rotatePiece();
                break;
            case 'drop':
                dropPiece();
                break;
        }
    }
    
    function handleKeyDown(event) {
        // 게임 상태와 관계없이 Enter, R, P 키는 기본 동작을 막을 필요가 없으므로 그대로 둡니다.
        if (event.key === 'Enter' || event.key === 'r' || event.key === 'R' || event.key === 'p' || event.key === 'P') {
            // 게임 시작/재개/일시정지 로직을 계속 처리합니다.
        } else if (event.key.startsWith('Arrow') || event.key === ' ') {
            // 방향키(Arrow Keys)와 스페이스바(Spacebar)의 기본 동작(스크롤)을 막습니다.
            event.preventDefault(); 
        }

        if (!isPlaying) {
            if (event.key === 'Enter') {
                startGame();
            } else if (event.key === 'r' || event.key === 'R') {
                resumeGame();
            }
            return;
        }

        // 게임 플레이 중 동작
        switch (event.key) {
            case 'ArrowLeft':
                handleUserInput('left');
                break;
            case 'ArrowRight':
                handleUserInput('right');
                break;
            case 'ArrowDown':
                handleUserInput('down');
                break;
            case 'ArrowUp':
                handleUserInput('rotate');
                break;
            case ' ': // Space bar for hard drop
                handleUserInput('drop');
                break;
            case 'p':
            case 'P':
                pauseGame();
                break;
        }
    }

    function gameOver() {
        isPlaying = false;
        clearInterval(gameLoop);
        statusElement.classList.remove('hidden');
        messageBox.textContent = `FINAL SCORE: ${score}`;
        
        startButton.textContent = 'RESTART GAME (Enter)';
        startButton.classList.remove('bg-red-500', 'bg-blue-500');
        startButton.classList.add('bg-green-500');

        document.removeEventListener('keydown', handleKeyDown);
        startButton.removeEventListener('click', pauseGame);
        startButton.removeEventListener('click', resumeGame);
        startButton.addEventListener('click', startGame);
        // 게임 오버 후에도 Enter 키로 재시작할 수 있도록 이벤트 리스너를 다시 등록합니다.
        document.addEventListener('keydown', (event) => {
            if (event.key === 'Enter') {
                startGame();
            }
        }, { once: true }); // 한 번만 실행되도록 설정
    }
    
    function startGame() {
        // 이미 게임이 시작되었거나 플레이 중인 경우 무시
        if (isPlaying) return;
        
        resetGame();
    }

    // 초기 상태 설정
    window.onload = () => {
        initBoard();
        scoreElement.textContent = 0;
        levelElement.textContent = START_LEVEL;
        statusElement.classList.add('hidden');
        
        // Next Piece 영역도 초기화
        nextPieceDisplay.innerHTML = '';
        
        // 초기 시작 버튼 이벤트 설정
        startButton.addEventListener('click', startGame);
        document.addEventListener('keydown', (event) => {
            if (event.key === 'Enter') {
                startGame();
            }
        }, { once: true }); // Enter 키로 게임 시작 이벤트는 한 번만 등록
    };
    
</script>

</body>
</html>
