<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tetris Web Game</title>
    <!-- Tailwind CSS 로드 -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* 커스텀 스타일 및 폰트 */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap');
        
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0d1117; /* GitHub Dark Theme */
        }
        
        /* 게임 화면 컨테이너 중앙 정렬 및 그림자 */
        #game-container {
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        /* 캔버스 스타일 */
        #tetris-canvas {
            border: 4px solid #38bdf8; /* Sky Blue Border */
            background-color: #010409; 
            box-shadow: 0 0 40px rgba(56, 189, 248, 0.5);
            /* 모바일에서 꽉 차게 보이도록 최대 너비 설정 */
            max-width: 100%;
            height: auto;
        }

        /* 폰트 크기 및 색상 */
        .game-title {
            color: #f87171; /* Red Accent */
            text-shadow: 1px 1px 3px rgba(0,0,0,0.5);
        }
    </style>
</head>
<body class="selection:bg-sky-400 selection:text-white">

<div id="game-container" class="w-full">
    
    <div class="flex flex-col lg:flex-row max-w-6xl w-full rounded-2xl overflow-hidden shadow-2xl bg-gray-900/80 backdrop-blur-sm p-4 md:p-8 space-y-8 lg:space-y-0 lg:space-x-8">

        <!-- 게임 영역 (캔버스) -->
        <div class="flex-shrink-0 flex justify-center items-center rounded-xl bg-gray-800 p-4 border-4 border-gray-700 w-full lg:w-[400px] aspect-[10/20] relative">
            <canvas id="tetris-canvas" width="300" height="600" class="rounded-lg shadow-inner"></canvas>
            
            <!-- 게임 오버 / 일시정지 오버레이 -->
            <div id="game-overlay" class="absolute inset-0 bg-black/80 flex flex-col justify-center items-center text-center rounded-lg hidden">
                <h2 id="overlay-title" class="text-4xl font-extrabold text-red-500 mb-2"></h2>
                <p id="overlay-message" class="text-xl text-white font-medium mb-4"></p>
                <button id="start-button" class="bg-sky-500 hover:bg-sky-600 text-white font-bold py-3 px-6 rounded-full shadow-lg transition duration-200 uppercase text-lg hidden">
                    재시작 (R)
                </button>
                <p id="pause-hint" class="text-gray-400 text-sm mt-4 hidden">P: 일시정지 / 다시 시작</p>
            </div>
        </div>

        <!-- 사이드바 (정보 패널) -->
        <div class="flex-grow flex flex-col space-y-6 text-white p-4">
            
            <h1 class="game-title text-5xl font-extrabold text-center mb-4 border-b-2 border-red-500/50 pb-2">
                WEB-TETRIS
            </h1>

            <!-- 현재 점수/레벨 -->
            <div class="bg-gray-700/50 p-4 rounded-xl shadow-lg border border-gray-600">
                <div class="flex justify-between items-center mb-2">
                    <span class="text-xl font-semibold text-gray-300">점수 (SCORE)</span>
                    <span id="score-display" class="text-4xl font-black text-yellow-400">0</span>
                </div>
                <div class="flex justify-between items-center">
                    <span class="text-xl font-semibold text-gray-300">단계 (STAGE)</span>
                    <span id="stage-display" class="text-4xl font-black text-red-500">1</span>
                </div>
                <div class="flex justify-between items-center mt-2">
                    <span class="text-lg font-medium text-gray-400">제거된 줄 (LINES)</span>
                    <span id="lines-display" class="text-2xl font-bold text-sky-400">0</span>
                </div>
            </div>

            <!-- 다음 블록 -->
            <div class="bg-gray-700/50 p-4 rounded-xl shadow-lg border border-gray-600">
                <h3 class="text-2xl font-bold text-center text-sky-400 mb-3">다음 블록 (NEXT)</h3>
                <div id="next-piece-container" class="flex justify-center items-center h-20 w-full">
                    <!-- 캔버스에 그릴 예정 -->
                    <canvas id="next-canvas" width="120" height="80" class="rounded-md"></canvas>
                </div>
            </div>
            
            <!-- 조작법 힌트 -->
            <div class="bg-gray-700/50 p-4 rounded-xl shadow-lg border border-gray-600 mt-auto">
                <h3 class="text-xl font-bold text-gray-300 mb-2">조작법</h3>
                <ul class="text-sm text-gray-400 space-y-1 list-none p-0">
                    <li><span class="font-mono text-yellow-400">← →</span> : 좌우 이동</li>
                    <li><span class="font-mono text-yellow-400">↑</span> / <span class="font-mono text-yellow-400">X</span> : 회전</li>
                    <li><span class="font-mono text-yellow-400">↓</span> : 소프트 드롭</li>
                    <li><span class="font-mono text-yellow-400">SPACE</span> : 하드 드롭</li>
                    <li><span class="font-mono text-yellow-400">P</span> : 일시정지</li>
                    <li><span class="font-mono text-yellow-400">R</span> : 재시작 (게임 오버 시)</li>
                </ul>
            </div>
        </div>
    </div>
</div>

<script>
    // --- 설정 및 상수 ---
    const COLS = 10;
    const ROWS = 20;
    const BLOCK_SIZE = 30; // 30px
    const CANVAS_WIDTH = COLS * BLOCK_SIZE; // 300
    const CANVAS_HEIGHT = ROWS * BLOCK_SIZE; // 600

    // 캔버스 및 컨텍스트
    const canvas = document.getElementById('tetris-canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = CANVAS_WIDTH;
    canvas.height = CANVAS_HEIGHT;

    const nextCanvas = document.getElementById('next-canvas');
    const nextCtx = nextCanvas.getContext('2d');
    
    // UI 요소
    const scoreDisplay = document.getElementById('score-display');
    const linesDisplay = document.getElementById('lines-display');
    const stageDisplay = document.getElementById('stage-display');
    const overlay = document.getElementById('game-overlay');
    const overlayTitle = document.getElementById('overlay-title');
    const overlayMessage = document.getElementById('overlay-message');
    const startButton = document.getElementById('start-button');
    const pauseHint = document.getElementById('pause-hint');

    // 색상 정의
    const COLORS = [
        '#010409',      // 0: Empty
        '#00FFFF',      // 1: I (Cyan)
        '#0000FF',      // 2: J (Blue)
        '#FF8000',      // 3: L (Orange)
        '#FFFF00',      // 4: O (Yellow)
        '#00FF00',      // 5: S (Green)
        '#800080',      // 6: T (Purple)
        '#FF0000',      // 7: Z (Red)
        '#FF00FF'       // 8: Special (Magenta)
    ];

    // 테트로미노 모양 정의
    // 파이썬 튜플을 자바스크립트 배열로 변환
    const SHAPES = [
        [],
        [[[0, 1], [1, 1], [2, 1], [3, 1]], [[2, 0], [2, 1], [2, 2], [2, 3]]],  // 1: I
        [[[0, 0], [0, 1], [1, 1], [2, 1]], [[1, 0], [2, 0], [1, 1], [1, 2]], [[0, 1], [1, 1], [2, 1], [2, 2]], [[1, 0], [1, 1], [0, 2], [1, 2]]], // 2: J
        [[[2, 0], [0, 1], [1, 1], [2, 1]], [[1, 0], [1, 1], [1, 2], [2, 2]], [[0, 2], [0, 1], [1, 1], [2, 1]], [[0, 0], [1, 0], [1, 1], [1, 2]]], // 3: L
        [[[0, 0], [1, 0], [0, 1], [1, 1]]], // 4: O
        [[[1, 0], [2, 0], [0, 1], [1, 1]], [[0, 0], [0, 1], [1, 1], [1, 2]]], // 5: S
        [[[1, 0], [0, 1], [1, 1], [2, 1]], [[1, 0], [1, 1], [2, 1], [1, 2]], [[0, 1], [1, 1], [2, 1], [1, 2]], [[1, 0], [0, 1], [1, 1], [1, 2]]], // 6: T
        [[[0, 0], [1, 0], [1, 1], [2, 1]], [[1, 0], [0, 1], [1, 1], [0, 2]]], // 7: Z
        [[[0, 0]]] // 8: Special (1x1)
    ];
    
    // --- 게임 상태 변수 ---
    let board;
    let currentPiece;
    let nextQueue;
    let score;
    let lines;
    let stage;
    let isGameOver;
    let isPaused;
    let dropInterval;
    let lastTime;
    let dropCounter;
    let bag;
    let animationFrameId; // 애니메이션 프레임 ID 저장

    // Pygame 버전에서 화면에 보이지 않도록 숨겨둔 윗부분 (총 22줄 사용)
    const HIDDEN_ROWS = 2;
    const TOTAL_ROWS = ROWS + HIDDEN_ROWS;

    // --- Piece 클래스 ---
    class Piece {
        constructor(shapeId) {
            this.shapeId = shapeId;
            this.shapes = SHAPES[shapeId];
            this.rotation = 0;
            this.matrix = this.shapes[this.rotation];
            this.x = Math.floor(COLS / 2) - 1;
            // 숨겨진 윗줄(y=0)에서 시작
            this.y = 0; 
            this.color = COLORS[shapeId];
        }

        rotate(direction) {
            if (this.shapeId === 4 || this.shapeId === 8) return;
            this.rotation = (this.rotation + direction + this.shapes.length) % this.shapes.length;
            this.matrix = this.shapes[this.rotation];
        }

        getBlocks(offsetX = 0, offsetY = 0) {
            return this.matrix.map(([dx, dy]) => ({
                x: this.x + dx + offsetX,
                y: this.y + dy + offsetY
            }));
        }
    }

    // --- 게임 초기화 및 재시작 ---
    function initGame() {
        // 보드는 TOTAL_ROWS로 초기화 (숨겨진 2줄 포함)
        board = Array(TOTAL_ROWS).fill(0).map(() => Array(COLS).fill(0));
        score = 0;
        lines = 0;
        stage = 1;
        isGameOver = false;
        isPaused = false;
        dropInterval = 1000; // 1초
        lastTime = 0;
        dropCounter = 0;
        bag = [];
        nextQueue = [];
        
        refillBag();
        // 다음 조각 큐를 미리 채움
        while (nextQueue.length < 3) {
             if (bag.length === 0) refillBag();
             nextQueue.push(bag.shift());
        }
        newPiece();
        updateUI();

        overlay.classList.add('hidden');
        pauseHint.classList.remove('hidden');

        if (typeof animationFrameId !== 'undefined') {
            cancelAnimationFrame(animationFrameId);
        }
        gameLoop();
    }

    // --- 로직 함수 ---

    function refillBag() {
        // 7-bag system 구현 (7개의 테트로미노를 한 번씩 사용 후 섞어서 다시 사용)
        const pieces = [1, 2, 3, 4, 5, 6, 7];
        // 피셔-예이츠 셔플 알고리즘
        for (let i = pieces.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [pieces[i], pieces[j]] = [pieces[j], pieces[i]];
        }
        bag.push(...pieces);
    }
    
    function newPiece() {
        const shapeId = nextQueue.shift();
        
        // 다음 큐 채우기 (3개 유지)
        while (nextQueue.length < 3) {
             if (bag.length === 0) refillBag();
             nextQueue.push(bag.shift());
        }

        currentPiece = new Piece(shapeId);
        
        if (checkCollision(0, 0)) {
            isGameOver = true;
            showOverlay("GAME OVER", `최종 점수: ${score}`);
        }
    }

    function checkCollision(dx, dy, piece = currentPiece, matrix = piece.matrix) {
        for (const [blockDx, blockDy] of matrix) {
            const x = piece.x + blockDx + dx;
            const y = piece.y + blockDy + dy;

            // 1. 수평 경계 검사
            if (x < 0 || x >= COLS) {
                return true;
            }
            
            // 2. 수직 경계 검사 (보드 바닥)
            if (y >= TOTAL_ROWS) {
                return true;
            }
            
            // 3. 보드 블록 검사: y >= 0 에서만 검사 (배열 인덱스 오류 방지)
            if (y >= 0 && board[y][x] !== 0) {
                return true; // 이미 블록이 있는 경우
            }
        }
        return false;
    }

    function movePiece(dx) {
        if (!checkCollision(dx, 0)) {
            currentPiece.x += dx;
        }
    }

    function rotatePiece(direction) {
        const originalRotation = currentPiece.rotation;
        const originalX = currentPiece.x;
        
        currentPiece.rotate(direction);
        
        // SRS (Super Rotation System) Kick Test
        const kickTests = [0, -1, 1, -2, 2]; 
        for (const offset of kickTests) {
            if (!checkCollision(offset, 0)) {
                currentPiece.x += offset;
                return; 
            }
        }
        
        // 회전 실패 시 원상 복구
        currentPiece.rotation = originalRotation;
        currentPiece.matrix = currentPiece.shapes[originalRotation];
        currentPiece.x = originalX;
    }

    function softDrop() {
        if (!checkCollision(0, 1)) {
            currentPiece.y += 1;
            score += 1; // 소프트 드롭 점수
            updateUI();
            return true;
        } else {
            lockPiece();
            return false;
        }
    }

    function hardDrop() {
        let yBefore = currentPiece.y;
        
        // 충돌할 때까지 계속 내립니다.
        while (!checkCollision(0, 1)) {
            currentPiece.y += 1;
        }
        
        // 하드 드롭 점수 계산 (떨어진 칸 수 * 2)
        score += (currentPiece.y - yBefore) * 2;
        updateUI();

        lockPiece();
    }

    function lockPiece() {
        for (const {x, y} of currentPiece.getBlocks()) {
            if (y >= 0 && y < TOTAL_ROWS && x >= 0 && x < COLS) {
                board[y][x] = currentPiece.shapeId;
            }
        }
        clearLines();
        newPiece();
    }

    function clearLines() {
        let linesCleared = 0;
        
        // 아래부터 위로 검사 (효율적)
        for (let y = TOTAL_ROWS - 1; y >= 0; y--) {
            if (board[y].every(cell => cell !== 0)) {
                // 줄 제거: 해당 줄을 제거하고 위에 새로운 빈 줄 추가
                board.splice(y, 1);
                board.unshift(Array(COLS).fill(0));
                linesCleared++;
                y++; // 줄이 제거되었으므로 인덱스를 다시 검사
            }
        }
        
        if (linesCleared > 0) {
            const lineScores = [0, 100, 300, 500, 800]; // 1줄, 2줄, 3줄, 4줄 점수
            score += lineScores[linesCleared] * stage;
            lines += linesCleared;
            checkStageUp();
            updateUI();
        }
    }

    function checkStageUp() {
        const newStage = Math.floor(lines / 10) + 1;
        if (newStage > stage) {
            stage = newStage;
            // 단계가 올라갈수록 드롭 간격 감소 (최소 100ms)
            dropInterval = Math.max(100, 1000 - (stage - 1) * 80);
        }
    }

    // --- 드로잉 함수 ---

    function drawBlock(context, x, y, color) {
        // Pygame 버전의 HIDDEN_ROWS를 반영하여 y좌표 조정 (캔버스에 표시될 위치)
        const adjusted_y = y - HIDDEN_ROWS; 
        
        if (adjusted_y < 0) return; // 숨겨진 윗부분은 그리지 않음

        const size = BLOCK_SIZE;
        const rectX = x * size;
        const rectY = adjusted_y * size;

        context.fillStyle = color;
        context.fillRect(rectX, rectY, size, size);
        
        // 입체감 및 하이라이트 효과
        const hexToRgb = hex => {
            const bigint = parseInt(hex.slice(1), 16);
            const r = (bigint >> 16) & 255;
            const g = (bigint >> 8) & 255;
            const b = bigint & 255;
            return [r, g, b];
        };

        const [r, g, b] = hexToRgb(color);
        
        // 하이라이트 (밝은 쪽)
        const highlight = `rgb(${Math.min(255, r + 40)}, ${Math.min(255, g + 40)}, ${Math.min(255, b + 40)})`;
        // 그림자 (어두운 쪽)
        const shadow = `rgb(${Math.max(0, r - 40)}, ${Math.max(0, g - 40)}, ${Math.max(0, b - 40)})`;

        // 1. 블록 외곽선
        context.strokeStyle = 'rgba(0,0,0,0.2)';
        context.lineWidth = 1;
        context.strokeRect(rectX, rectY, size, size);

        // 2. 입체감 (하이라이트 및 그림자)
        context.strokeStyle = highlight;
        context.lineWidth = 2;
        context.beginPath();
        context.moveTo(rectX, rectY);
        context.lineTo(rectX + size, rectY);
        context.lineTo(rectX, rectY);
        context.lineTo(rectX, rectY + size);
        context.stroke();

        context.strokeStyle = shadow;
        context.lineWidth = 2;
        context.beginPath();
        context.moveTo(rectX + size, rectY);
        context.lineTo(rectX + size, rectY + size);
        context.lineTo(rectX, rectY + size);
        context.lineTo(rectX + size, rectY + size);
        context.stroke();
    }

    function draw() {
        // 1. 배경 클리어 및 격자 그리기
        ctx.fillStyle = '#010409';
        ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        
        ctx.strokeStyle = '#282c34';
        ctx.lineWidth = 1;
        for (let x = 0; x < COLS; x++) {
            for (let y = 0; y < ROWS; y++) {
                // y는 0부터 ROWS-1까지의 화면 좌표
                ctx.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            }
        }

        // 2. 고정된 블록 그리기
        // board는 TOTAL_ROWS(22) 크기이므로, y >= HIDDEN_ROWS인 부분만 그립니다.
        board.forEach((row, y) => {
            if (y >= HIDDEN_ROWS) {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        drawBlock(ctx, x, y, COLORS[value]);
                    }
                });
            }
        });

        // 3. 고스트 피스 그리기
        if (currentPiece && !isPaused && !isGameOver) {
            const ghostY = getGhostY();
            const piece = currentPiece;
            
            ctx.globalAlpha = 0.3; // 반투명 설정
            piece.matrix.forEach(([dx, dy]) => {
                drawBlock(ctx, piece.x + dx, ghostY + dy, piece.color);
            });
            ctx.globalAlpha = 1.0; // 투명도 초기화
            
            // 4. 현재 블록 그리기
            piece.matrix.forEach(([dx, dy]) => {
                drawBlock(ctx, piece.x + dx, piece.y + dy, piece.color);
            });
        }
        
        // 5. 다음 블록 그리기 (사이드바)
        drawNextPiece();
    }

    function getGhostY() {
        let y = currentPiece.y;
        while (!checkCollision(0, 1)) {
            currentPiece.y++;
        }
        const ghostY = currentPiece.y;
        currentPiece.y = y; // 원래 위치 복구
        return ghostY;
    }

    function drawNextPiece() {
        nextCtx.fillStyle = '#010409';
        nextCtx.fillRect(0, 0, nextCanvas.width, nextCanvas.height);
        
        if (nextQueue.length > 0) {
            const nextId = nextQueue[0];
            const shape = SHAPES[nextId][0];
            const color = COLORS[nextId];
            const miniSize = 20;

            // 중앙 정렬을 위한 계산
            const allX = shape.map(([dx, dy]) => dx);
            const allY = shape.map(([dx, dy]) => dy);
            const minX = Math.min(...allX);
            const maxX = Math.max(...allX);
            const minY = Math.min(...allY);
            const maxY = Math.max(...allY);

            const pieceWidth = (maxX - minX + 1) * miniSize;
            const pieceHeight = (maxY - minY + 1) * miniSize;

            const offsetX = (nextCanvas.width - pieceWidth) / 2 - minX * miniSize;
            const offsetY = (nextCanvas.height - pieceHeight) / 2 - minY * miniSize;

            shape.forEach(([dx, dy]) => {
                const x = offsetX + dx * miniSize;
                const y = offsetY + dy * miniSize;
                
                nextCtx.fillStyle = color;
                // 블록 간에 약간의 간격을 위해 1px 뺌
                nextCtx.fillRect(x, y, miniSize - 1, miniSize - 1); 
                nextCtx.strokeStyle = 'rgba(255,255,255,0.2)';
                nextCtx.strokeRect(x, y, miniSize - 1, miniSize - 1);
            });
        }
    }

    function updateUI() {
        scoreDisplay.textContent = score;
        linesDisplay.textContent = lines;
        stageDisplay.textContent = stage;
    }

    function showOverlay(title, message) {
        overlayTitle.textContent = title;
        overlayMessage.textContent = message;
        overlay.classList.remove('hidden');
        pauseHint.classList.add('hidden');

        if (isGameOver) {
            startButton.classList.remove('hidden');
        } else {
            startButton.classList.add('hidden');
        }
    }


    // --- 메인 루프 ---

    function gameLoop(time = 0) {
        const deltaTime = time - lastTime;
        lastTime = time;

        if (!isGameOver && !isPaused) {
            dropCounter += deltaTime;
            if (dropCounter > dropInterval) {
                softDrop();
                dropCounter = 0;
            }
        }
        
        draw();
        
        // requestAnimationFrame은 브라우저의 렌더링 주기에 맞춰 호출됩니다.
        animationFrameId = requestAnimationFrame(gameLoop);
    }
    
    // --- 이벤트 리스너 ---

    document.addEventListener('keydown', event => {
        if (isGameOver) {
            if (event.key === 'r' || event.key === 'R') {
                initGame();
            }
            return;
        }

        if (event.key === 'p' || event.key === 'P') {
            isPaused = !isPaused;
            if (isPaused) {
                showOverlay("일시정지", "P 키를 눌러 다시 시작");
            } else {
                overlay.classList.add('hidden');
                pauseHint.classList.remove('hidden');
            }
            return;
        }

        if (isPaused) return;

        switch (event.key) {
            case 'ArrowLeft':
                movePiece(-1);
                break;
            case 'ArrowRight':
                movePiece(1);
                break;
            case 'ArrowUp':
            case 'x':
            case 'X':
                rotatePiece(1);
                break;
            case 'ArrowDown':
                // 소프트 드롭을 즉시 실행하고 드롭 카운터를 초기화하여 다음 자동 드롭을 늦춥니다.
                softDrop();
                dropCounter = 0;
                break;
            case ' ': // Space bar for hard drop
                event.preventDefault(); // 스페이스바가 스크롤되는 것을 방지
                hardDrop();
                break;
        }
        draw();
    });

    // 재시작 버튼 클릭 이벤트
    startButton.addEventListener('click', initGame);

    // 초기 실행
    initGame(); 
</script>

</body>
</html>